     | 1 Урок. 19.09 |
Гит.
Гит имеет историю действий. Что позволяет в конце работы (финализация работы) всё объединить.
Или же замеждить файлы. Отличное решение для работы в команде. Также есть Commit, это точка сохранения.
С0 - С1 - С2
   \
     - С3
Здесь С1 хранит изменения над файлом С0. Изменения С2 хранит относительно С1. В них хранится изменения 
и (к)ХЭШ. Каждый коммит имеет свой уникальный номер, что хранится в ХЭШ. 
Mesh - это объединение 2-ух коммитов. Могут быть кофликты. Напрмер, в одном из коммитов были 
задействованы файлы одинаковые, но использование их разное. 
Гит безотказный. Создаем репозиторий. Это область, что хранит информацию о проекте.
 rep - С0 - С1 - С2
      \
        - С3
Все изменения архивируется, оптимизируется и т.п. хранится в репозитории. Есть облако, что позволит
откатить всё, даже при удалении или потери репозитория.

 rep - С0 - С1 - С2
   |   \
   |    - С3
   |
Cloud

Будем писать код на Визуалке.
SSH ссылка нужна для ?ключей?.
Remotes в Fork - это облако. Туда кидаем всё и дома я могу скачать. 
Pull - изменения из облака накатит на локальные на пк. 
Push - коммиты С4 идут в облако из локалки.

Скачать данные дома.
____________________________________________________________________________________________________________________________________________________________________________

              | Лекция 2 |

 Resources
    |
[lession1] -> [lession2] - > ... -> [lession7] .... [n] -> [lession36] - > Project is ready
    |  -> result                             \
    Technology                                [Personal project]

Можно попросить любого преподавателя раскрыть любую тему. 
Двойной клик на коммит, тем самым можно создать новую ветку и от нее развивать тему.

Тема: память. Важно!!!
В любом ЯП управляют памятью. С++ память управляется программистом, а в С# всё упростили, он высокоуровневый. 
Шарп имеет два блока памяти 1 стек и 2 куча. Стек маленький ящик, а куча большая. Стек очень быстрая память в которой внутри всё упорядочено, форматируется быстро. 
Она является процессорной памятью, а куча оперативная. В стек мы не лезем, так всё ок. А куча нет, там много релокаций. Мы написали переменные и забыли о них, а они висят.
В Шарпе есть провекрка, есть ли ссылка на эту ячейку. Что этот процесс является очень ресурсоёмким. Из-за этого игра висла. 
Решение - меньше лоцировать. Как меньше приходить к куче. 
Лоцировать - определять (определить) местоположение какого-либо объекта с помощью специальных устройств, органов.

short s = 0;
int i = 0;
long l = 0;
float f =0;
double d = 0;

Хранятся в стеке. Т.е. всё ок.

object n = d; - операция боксинга.

Оно хранится в куче. Т.к. обдект является самым базовым элементом и является ссылочным.
Ссылочный тип можно передать как параметр. 
Ссылочные хрантятся в куча, а не ссылочные в стеке.

double d2 = (double)n;

Это анбоксиннг. Ничего нет такого в этом, но это релокация. В мобилке очень критично может быть. 

long l2 = short.MaxValue;
Тут лонг урежится до шорта.

Тема 2. Методы. 

public void TestFunc(int i)
{
    i = 10;
    Debug.Log(i);
}

public void TestFunc2(in int i)
{
    i = 10;
    Debug.Log(i);
}

in делает i в ссылочный тип. Но без бокс и анбокса. Но это будет безопаснее, чем делать боксинг и анбоксинг.

public void TestFunc3(out int i)
{
    i = 10;
    Debug.Log(i);
}

Здесь важно присовить значение i. 

Переменные хранятся в памяти. Мало того, что Object находится в куча, там ещё и в стеке. Мои основные данные хранятся в куче. Все переменные типа struct хранятся в стеке, а находятся в куче.

int i3;
Myclass mc = new Myclass();

New говорит, что надо выделить новую ячейку в памяти. 

Myclass mc = new Myclass();
TestFunc3(mc);

public void TestFunc3(Myclass mc)
{
    
}

Сам класс и ее переменные попадают в кучу. 
Ещё вызовы друг друга вызывают перегруз. Новая переменная - куча. Всё идет в кучу. 
В классе ничего нет. Мы просто передали ее в класс, сделали ее ссылочной и можно с ней делать что угодно. 
Myclass mc = new Myclass();
TestFunc3(out mc);

public void TestFunc3(out Myclass mc)
{
    
}

Добивив аут, переменная создает её копию. Лучше ссылочными типа не пользоваться. 

VAR. Это тот тип данных, что сам определяет данные. Он неопределнный. С# создавался, что ни о чем не думать, ни о памяти, типы данных. Ксти, у C# пробемы с памятью из-за этого. 
Каждый класс должен быть назван только односложно, только одну функцию выполнять. 

Класс - это набор данных. И класс хранит строку, число. Если передать значение в функцию, то просто ссылка отправится к ссылке не заняв ячейки памяти.  
Если mc перезаписать на mc2, то создаться грубо говоря mc3, а mc удалится изанчальный. И содатся новая ячейка.

Когда использовать ссылочный тип. 
Пока ею пользуются, она живет и находится в куче. Стукутра используется для атомарных переменных, вектор 1,2,3, индексы. Что-то маленькое. Ибо стурктура часто передается, нужна безопаснсоть.

Область видимости.
{} - мы стартовали в область видимости. 
Есть в {} создать ещё одну, то это отдельная обалсть видимости. (if. else, for). Если в if создана i2, то за этой обасти видимости, не будет доступна i2. 
После области видимости i2 будет полностью уничтожена. Но это не касается классов и структур и ссылочные в целом (объявить её public).

for(int i = 0...)
for(int i = 0...)
они не конфликтуют. Ибо у них своя область видимости.

Массивы.

int[] array = new int[3]. Создалось 3 инта! Т.е. 3 ячейки памяти занялось. Массив хорош тем, что он быстр по перемещению. Его данные хранятся в одной плоскости. В одной последовательнсоти. 
Т.к. это ссылочный тип он хранится в куче. Ещё он выделяет весь кусок памяти и работает с ним. есл будет не хватать, то не зарабоатет. Их можно перебирать. Все игры аппелируют с даннными.
Данные игрока, их параметров...
Если правильно упорядочить данные, то и само приложение будет быстрее работать. 
!!!Использовать стек и массивы.!!! Самый топ. Этим можно 1 млн игроков на сервере и чтобы всё ломалось, взрывалось.

Если создавали object[] array = new object[3]. Тут выйдет что инт будет хравиться в куче, инт - который нумерация объектов. А сами объекты, т.е. их тип, разбросан в куче.
Стараться создавать коллекции 
строго типизированные.
Массив хорош ием, что он лежит в большой ячейке, легко и быстро читать. Друг за другом. А объект, сначала его инт - номер, потом поиск пути к самому объекту. 

List<int> List = new List<int>(); Это динамический массив. Он создал массив из четырех данных. Если доьавить новый элемент, т он удалить массив на 4 и создаст сразу на 8...16...32 туда где есть свободное место.
Пока живет лист, то и живет сам массив.

ДЗ\ Написать свой лист. 
Наш лист имеет в себе массив из 4-ех чисел. Нужен пример где будет создан лист и операции. Пуш (0-10), потом удалить что-то. И вывесли того. Что сот алсось в листе. 
public class MyList
{
	private int[] m_array = new int[4]
	public int count {get; }
	public void Push(int i)
	{ 

	}
	public int Insert(int item)
	{
	}

	public int IndexOF(int item)
	{
		return 0;
	}
	public int Remove(int item)
	{
	
	}
	public int RemoveAt(int item)
	{
		
	}
	public int Clear(int item)
	{
	
	}
}



____________________________________________________________________________________________________________________________________________________
 

             | Лекция 3 |

Стек и куча. 

MyClass mc = new Myclass 
Слева это переменная - это ссылка которая хранится в стеке, а new Meclass это хранится в куче. 
Когда создаем в функции переменные и в целом новое создаем - стек. 
Содержимое класса хранится в куче. Ибо это ссылочный тип. Тоже это касается и массивов. 
int out ref работает для классов тоже. Мы не создаем новую переменную MyClass mc2 = mc. То эта переменная просто копирует mc и накладывает на mc2. При этом копируя ячеку из стека в стек.
____
В гит игнор добавить всё кроме 3 папок
____
List - это просто хранилище ссылок на следующую ячейку. Причем в памяти они могут храниться в разброс.
Input List - можно перезаписать ячейку.
Вектор - позволяет управлять стурктурами данных.
У каждой структуры данных есть своя сложность при выполнении дейтсвий разных. 
В играх хватает прохода по массиву. 
Capacity - резерв выбранного массива. Массив сам по себе неизменяемый. Лист динамический массив, его можно расширять и умеьшать. 
______________
Задание. Исправить ошибки. Надо будет перемести MyClass на Engine?. Проверить скороть моего листа. 
Stopwatch sw = Stopwatch.StartNew();
for(int i = 0; i < 10000; i++)
{
myList.Push(new MyClass());
}
Debug.Log(sw.ElpasedMillisecond);
sw = System.Diagnostics.Stopwatch.StartNew();
______________________
Джинерик - это класс.

mYLIXT<item> - это дженерик класс. 
Можно указать что дженерик будет рабоатть с определнным классом. where T : MyClass. 
Принести свой проект на пару. Залит на гитхаб. Новый репозиторий
_________________________________________________________________________________________________________________________________________________________

Unity - набор инстурментов для создания игр. 

Юнити защищает от множества ошибок. Плюс - это защита ядра. А минус - это скорость работы игры. 
Игра - это приложение. 
Юнити работает так
While(true)
{
FixedUpdate();
Update();
Render();
LateUpdate();
}
Если это всё прошло, то это 1 кадр. Не больше 16 млс на выполнение всех 4-ех методов.

ООП работает так: | Gameobj -> Transform -> MeshRender | -> BoxCollider | -> Weapon | это раньше.

Юнити использует композитную структуру. 
GameObject ( Name, Layer) - является контейнером.

Игра Защита башен

GO -> Hp жизни 
   -> Search поиск врагов
   -> Canon виды снарядов 
   -> Upgrade улучшения

Должна быть точка входа. Нужно начало!!! 
Как начать игру? 

______

Урок 4 дату надо везде ПОСТАВИТЬ

Htylth gfqgkfby - 'nj способ обаботки изображения. Universal это те метариалы, что будут запускаться за любых систепмах

Иерархия.1. Assects -> art(content, URP, Volume)
Models and Prefabs
Тектуры    Тут всё готовое
Модели

Maps 
Props - 1. Road side 2. Buildings 3. Buildboards

Юнити все равно на расположение файлов, оно хранится в мета файле. Т.е. если ты перенесешь данные с папки в папку, то юнити найдет ее.
В юнити идет работа с префабами, не с объектами!!!
ДЗ - взять проект (свой), те же самые действия что сегодня. Арты по иерархии раскидать. Ассет стор, префабы по иерархии раскдать. Персонажи, дома, растения. 
Все материалы были URP. Можно сделать своё или скачать и закинуть. Только со стороны арта сделать! 
____________________________________________________________________________________________________________________________________________________________
Урок 5 03.10.2023
Дмитрий:
Вступление - это максимальное счастье. 	80% счастья
Первые трудности - счастье убывает сильно - 20% счастья
Решение трудности - подъем счастья. 80%.
Увлечение - примерно 80% держится счастье.

Идеальный уровень счастья игркока - это 70%. Но чтобы это было в меру. То подъем, то спад.
Нужно держать баланс между активностью и паузы.

Почему в байте 8 бит - почитать!!!
Кьюбиты?
Линкетлист?

Класс Spawn. Ошибка многих. Туда пихают другие функции.
Spawn - спавнит разные объекты, чтобы для всех использовать.


1 Итерация - 1. Цель - определить смогу ли я вести свой проект. 
1.1.Sample Project  - шутер. 
1.2. Свой проект (Описан концепт и команда участвиков)2+ чела. (макс 6)

Надо реализовывать и победы и поражения.
Власть - Деньги - Любовь - (знания)

Что было
+ ответственность 
+ творчество (откл по ТЗ)
+ Упорство
- Время
- поиграть не во что
- сборка игры (тех проблемы)

Резюме
1. всего 2300 часов осталось. 
2. 













































































